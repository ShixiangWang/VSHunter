% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnv_main.R
\name{cnv_chooseSigNumber}
\alias{cnv_chooseSigNumber}
\title{Choose optimal number of signatures}
\usage{
cnv_chooseSigNumber(sample_by_component, nTry = 12, nrun = 10,
  cores = 1, seed = 123456, plot = TRUE,
  consensusmap_name = "nmf_consensus", testRandom = TRUE,
  nmfalg = "brunet")
}
\arguments{
\item{sample_by_component}{a sample-by-component \code{matrix}, generate from \link{cnv_generateSbCMatrix} function.}

\item{nTry}{the maximal tried number of signatures, default is 12.
Of note, this value should far less than number of features or samples.}

\item{nrun}{the number of run to perform for each value in range of 2 to \code{nTry}, default is 10.
According to \strong{NMF} package documentation, \code{nrun} set to 30~50 is enough to achieve robust result.}

\item{cores}{number of compute cores to run this task.
You can use \code{\link[parallel:detectCores]{parallel::detectCores()}} function to check how
many cores you can use. If you are using \code{\link[=cnv_pipe]{cnv_pipe()}} feature,
please do not use maximal number of
cores in your computer, it may cause some unexpected problems.}

\item{seed}{seed number.}

\item{plot}{logical. If \code{TRUE}, plot rank survey.}

\item{consensusmap_name}{a character, basename of consensus map output path.}

\item{testRandom}{Should generate random data from input to test measurements. Default is \code{TRUE}.}

\item{nmfalg}{specification of the NMF algorithm.}
}
\value{
a \code{list} contains information of NMF run and rank survey.
}
\description{
This function use \strong{NMF} package to evaluate the optimal number of signatures.
The most common approach is to choose the smallest rank for which cophenetic correlation coefficient
starts decreasing (Used by this function). Another approach is to choose the rank for which the plot
of the residual sum of squares (RSS) between the input matrix and its estimate shows an inflection point.
}
\examples{
\dontrun{
## load example copy-number data from tcga
load(system.file("inst/extdata", "example_cn_list.RData", package = "VSHunter"))
## generate copy-number features
tcga_features = cnv_derivefeatures(CN_data = tcga_segTabs, cores = 1, genome_build = "hg19")
## fit mixture model  (this will take some time)
tcga_components = cnv_fitMixModels(CN_features = tcga_features, cores = 1)
## generate a sample-by-component matrix
tcga_sample_component_matrix = cnv_generateSbCMatrix(tcga_features, tcga_components, cores = 1)
## optimal rank survey
 tcga_sig_choose = cnv_chooseSigNumber(tcga_sample_component_matrix,
 nrun = 10, cores = 1, plot = FALSE)
}

}
\seealso{
Other CNV analysis functions: \code{\link{cnv_autoCaptureSignatures}},
  \code{\link{cnv_derivefeatures}},
  \code{\link{cnv_extractSignatures}},
  \code{\link{cnv_fitMixModels}},
  \code{\link{cnv_generateSbCMatrix}},
  \code{\link{cnv_getLengthFraction}},
  \code{\link{cnv_pipe}},
  \code{\link{cnv_plotDistributionProfile}},
  \code{\link{cnv_plotFeatureDistribution}},
  \code{\link{cnv_plotMixComponents}},
  \code{\link{cnv_plotSignatures}},
  \code{\link{cnv_quantifySigExposure}},
  \code{\link{cnv_readprofile}}
}
\author{
Geoffrey Macintyre, Shixiang Wang
}
\concept{CNV analysis functions}
